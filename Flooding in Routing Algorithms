        #define MAX_NODES 1024        /* maximum number of nodes */
        #define INFINITY 1000000000   /* a number larger than every maximum path */

        int n, dist[MAX_NODES][MAX_NODES]; /* dist[i][j] is the distance from i to j */

        /* Function to find the shortest path from node s to node t */
        void shortest_path(int s, int t, int path[]) {
            struct state {
                int predecessor;         /* previous node */
                int length;              /* length from source to this node */
                enum { permanent, tentative } label; /* label state */
            } state[MAX_NODES];

            int i, k, min;
            struct state *p;

            /* Initialize state */
            for (p = &state[0]; p < &state[n]; p++) {
                p->predecessor = -1;
                p->length = INFINITY;
                p->label = tentative;
            }

            state[t].length = 0;
            state[t].label = permanent;

            k = t; /* k is the initial working node */

            do {
                /* Is there a better path from k? */
                for (i = 0; i < n; i++) { /* this graph has n nodes */
                    if (dist[k][i] != 0 && state[i].label == tentative) {
                        if (state[k].length + dist[k][i] < state[i].length) {
                            state[i].predecessor = k;
                            state[i].length = state[k].length + dist[k][i];
                        }
                    }
                }

                /* Find the tentatively labeled node with the smallest label. */
                k = 0;
                min = INFINITY;
                for (i = 0; i < n; i++) {
                    if (state[i].label == tentative && state[i].length < min) {
                        min = state[i].length;
                        k = i;
                    }
                }
                state[k].label = permanent;
            } while (k != s); /* Loop until we reach the source node */

            /* Copy the path into the output array. */
            i = 0;
            k = s;
            do {
                path[i++] = k;
                k = state[k].predecessor;
            } while (k >= 0);
        }

        int main() {
            // Example graph setup (distances between nodes)
            n = 5;  // Number of nodes
            dist[0][1] = 10; dist[0][2] = 5; dist[1][2] = 2; dist[1][3] = 1;
            dist[2][1] = 3; dist[2][3] = 9; dist[2][4] = 2; dist[3][4] = 4;
            dist[4][0] = 7; dist[4][3] = 6; 

            int s = 0, t = 4;
            int path[MAX_NODES];
            
            shortest_path(s, t, path);
            
            printf("Shortest path from %d to %d:\n", s, t);
            for (int i = 0; path[i] != -1; i++) {
                printf("%d ", path[i]);
            }
            printf("\n");

            return 0;
        }
